c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
set.seed(123)
# Define parameters
n1 <- 1195
n2 <- 750
n3 <- 729
n4 <- 326
n <- n1 + n2 + n3 + n4
# Set up functions to find MLE
score_counts <- function(theta, c1, c2, c3, c4) {
score <- c1 / (2 + theta) - (c2 + c3) / (1 - theta) + c4 / theta
return(score)
}
mle <- function(c1, c2, c3, c4) {
f <- function(t) score_counts(t, c1, c2, c3, c4)
test_lower <- score_counts(0.001, c1, c2, c3, c4)
test_upper <- score_counts(0.999, c1, c2, c3, c4)
cat("f(0.001) =", test_lower, "\n")
cat("f(0.999) =", test_upper, "\n")
cat("c1:", c1, "\n")
cat("c2:", c2, "\n")
cat("c3:", c3, "\n")
cat("c4:", c4, "\n")
mle <- uniroot(f, lower = 1e-3, upper = 1-1e-3)
return(mle$root)
}
# Calculate the original MLE for comparison
theta_hat_obs <- mle(n1, n2, n3, n4)
### Non-Parametric Bootstrap
# Create a vector of raw categories
cats <- c(rep("StG", n1), rep("StW", n2), rep("SuG", n3), rep("SuW", n1))
# Define number of bootstrap sims and initialize a vector to hold theta_stars
B <- 2000
theta_star_nonpar <- numeric(B)
# Loop through sims
for (b in 1:B) {
# Sample cats vector with replacement
sample <- sample(cats, size = n, replace = TRUE)
# Count the number of each type
c1_boot <- sum(sample == "StG")
c2_boot <- sum(sample == "StW")
c3_boot <- sum(sample == "SuG")
c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Approximate the standard deviation of the MLE
sd_nonpar = sd(theta_star_nonpar)
### Parametric Bootstrap
# Initialize a vector to store results
theta_star_par <- numeric(B)
# Compute probabilities for each type based on theta_hat_observed
p1 <- (2 + theta_hat_obs) / 4
p2 <- (1 - theta_hat_obs) / 4
p3 <- (1 - theta_hat_obs) / 4
p4 <- theta_hat_obs / 4
# Run bootstap sims
for (b in 1:B) {
# Generate data from multinomial distribution
new_counts <- rmultinom(1, size = n, prob = c(p1, p2, p3, p4))
# Count number of each type
c1_boot <- new_counts[1]
c2_boot <- new_counts[2]
c3_boot <- new_counts[3]
c4_boot <- new_counts[4]
# Compute mle from simulated data
theta_star_par[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Calculate parametric standard deviation
sd_par <- sd(theta_star_par)
# Calculate bounds of confidence interval for each
lower_bound_nonpar <- theta_hat_obs - 1.96 * sd_nonpar
upper_bound_nonpar <- theta_hat_obs + 1.96 * sd_nonpar
lower_bound_par <- theta_hat_obs - 1.96 * sd_par
upper_bound_par <- theta_hat_obs + 1.96 * sd_par
# Print results
cat("Original MLE:", round(theta_hat_obs, 4), "\n\n")
cat("Nonparametric 95% CI: (",
round(lower_bound_nonpar, 4), ",",
round(upper_bound_nonpar, 4), ")\n")
cat("Parametric 95% CI:    (",
round(lower_bound_par, 4), ",",
round(upper_bound_par, 4), ")\n")
set.seed(123)
# Define parameters
n1 <- 1195
n2 <- 750
n3 <- 729
n4 <- 326
n <- n1 + n2 + n3 + n4
# Set up functions to find MLE
score_counts <- function(theta, c1, c2, c3, c4) {
score <- c1 / (2 + theta) - (c2 + c3) / (1 - theta) + c4 / theta
return(score)
}
mle <- function(c1, c2, c3, c4) {
f <- function(t) score_counts(t, c1, c2, c3, c4)
test_lower <- score_counts(0.001, c1, c2, c3, c4)
test_upper <- score_counts(0.999, c1, c2, c3, c4)
mle <- uniroot(f, lower = 1e-3, upper = 1-1e-3)
return(mle$root)
}
# Calculate the original MLE for comparison
theta_hat_obs <- mle(n1, n2, n3, n4)
### Non-Parametric Bootstrap
# Create a vector of raw categories
cats <- c(rep("StG", n1), rep("StW", n2), rep("SuG", n3), rep("SuW", n1))
# Define number of bootstrap sims and initialize a vector to hold theta_stars
B <- 2000
theta_star_nonpar <- numeric(B)
# Loop through sims
for (b in 1:B) {
# Sample cats vector with replacement
sample <- sample(cats, size = n, replace = TRUE)
# Count the number of each type
c1_boot <- sum(sample == "StG")
c2_boot <- sum(sample == "StW")
c3_boot <- sum(sample == "SuG")
c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Approximate the standard deviation of the MLE
sd_nonpar = sd(theta_star_nonpar)
### Parametric Bootstrap
# Initialize a vector to store results
theta_star_par <- numeric(B)
# Compute probabilities for each type based on theta_hat_observed
p1 <- (2 + theta_hat_obs) / 4
p2 <- (1 - theta_hat_obs) / 4
p3 <- (1 - theta_hat_obs) / 4
p4 <- theta_hat_obs / 4
# Run bootstap sims
for (b in 1:B) {
# Generate data from multinomial distribution
new_counts <- rmultinom(1, size = n, prob = c(p1, p2, p3, p4))
# Count number of each type
c1_boot <- new_counts[1]
c2_boot <- new_counts[2]
c3_boot <- new_counts[3]
c4_boot <- new_counts[4]
# Compute mle from simulated data
theta_star_par[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Calculate parametric standard deviation
sd_par <- sd(theta_star_par)
# Calculate bounds of confidence interval for each
lower_bound_nonpar <- theta_hat_obs - 1.96 * sd_nonpar
upper_bound_nonpar <- theta_hat_obs + 1.96 * sd_nonpar
lower_bound_par <- theta_hat_obs - 1.96 * sd_par
upper_bound_par <- theta_hat_obs + 1.96 * sd_par
# Print results
cat("Original MLE:", round(theta_hat_obs, 4), "\n\n")
cat("Nonparametric 95% CI: (",
round(lower_bound_nonpar, 4), ",",
round(upper_bound_nonpar, 4), ")\n")
cat("Parametric 95% CI:    (",
round(lower_bound_par, 4), ",",
round(upper_bound_par, 4), ")\n")
set.seed(123)
# Define parameters
n1 <- 1195
n2 <- 750
n3 <- 729
n4 <- 326
n <- n1 + n2 + n3 + n4
# Set up functions to find MLE
score_counts <- function(theta, c1, c2, c3, c4) {
score <- c1 / (2 + theta) - (c2 + c3) / (1 - theta) + c4 / theta
return(score)
}
mle <- function(c1, c2, c3, c4) {
f <- function(t) score_counts(t, c1, c2, c3, c4)
test_lower <- score_counts(0.001, c1, c2, c3, c4)
test_upper <- score_counts(0.999, c1, c2, c3, c4)
mle <- uniroot(f, lower = 1e-3, upper = 1-1e-3)
return(mle$root)
}
# Calculate the original MLE for comparison
theta_hat_obs <- mle(n1, n2, n3, n4)
### Non-Parametric Bootstrap
# Create a vector of raw categories
cats <- c(rep("StG", n1), rep("StW", n2), rep("SuG", n3), rep("SuW", n1))
# Define number of bootstrap sims and initialize a vector to hold theta_stars
B <- 2000
theta_star_nonpar <- numeric(B)
# Loop through sims
for (b in 1:B) {
# Sample cats vector with replacement
sample <- sample(cats, size = n, replace = TRUE)
# Count the number of each type
c1_boot <- sum(sample == "StG")
c2_boot <- sum(sample == "StW")
c3_boot <- sum(sample == "SuG")
c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Approximate the standard deviation of the MLE
sd_nonpar = sd(theta_star_nonpar)
### Parametric Bootstrap
# Initialize a vector to store results
theta_star_par <- numeric(B)
# Compute probabilities for each type based on theta_hat_observed
p1 <- (2 + theta_hat_obs) / 4
p2 <- (1 - theta_hat_obs) / 4
p3 <- (1 - theta_hat_obs) / 4
p4 <- theta_hat_obs / 4
# Run bootstap sims
for (b in 1:B) {
# Generate data from multinomial distribution
new_counts <- rmultinom(1, size = n, prob = c(p1, p2, p3, p4))
# Count number of each type
c1_boot <- new_counts[1]
c2_boot <- new_counts[2]
c3_boot <- new_counts[3]
c4_boot <- new_counts[4]
# Compute mle from simulated data
theta_star_par[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Calculate parametric standard deviation
sd_par <- sd(theta_star_par)
# Calculate bounds of confidence interval for each
lower_bound_nonpar <- theta_hat_obs - 1.96 * sd_nonpar
upper_bound_nonpar <- theta_hat_obs + 1.96 * sd_nonpar
lower_bound_par <- theta_hat_obs - 1.96 * sd_par
upper_bound_par <- theta_hat_obs + 1.96 * sd_par
# Print results
cat("Original MLE:", round(theta_hat_obs, 4), "\n\n")
cat("Nonparametric 95% CI: (",
round(lower_bound_nonpar, 4), ",",
round(upper_bound_nonpar, 4), ")\n")
cat("Parametric 95% CI:    (",
round(lower_bound_par, 4), ",",
round(upper_bound_par, 4), ")\n")
cat("True 95% CI: (0.2127,0.2547)\n")
set.seed(123)
# Define parameters
n1 <- 1195
n2 <- 750
n3 <- 729
n4 <- 326
n <- n1 + n2 + n3 + n4
# Set up functions to find MLE
score_counts <- function(theta, c1, c2, c3, c4) {
score <- c1 / (2 + theta) - (c2 + c3) / (1 - theta) + c4 / theta
return(score)
}
mle <- function(c1, c2, c3, c4) {
f <- function(t) score_counts(t, c1, c2, c3, c4)
test_lower <- score_counts(0.001, c1, c2, c3, c4)
test_upper <- score_counts(0.999, c1, c2, c3, c4)
mle <- uniroot(f, lower = 1e-3, upper = 1-1e-3)
return(mle$root)
}
# Calculate the original MLE for comparison
theta_hat_obs <- mle(n1, n2, n3, n4)
### Non-Parametric Bootstrap
# Create a vector of raw categories
cats <- c(rep("StG", n1), rep("StW", n2), rep("SuG", n3), rep("SuW", n1))
# Define number of bootstrap sims and initialize a vector to hold theta_stars
B <- 2000
theta_star_nonpar <- numeric(B)
# Loop through sims
for (b in 1:B) {
# Sample cats vector with replacement
sample <- sample(cats, size = n, replace = TRUE)
# Count the number of each type
c1_boot <- sum(sample == "StG")
c2_boot <- sum(sample == "StW")
c3_boot <- sum(sample == "SuG")
c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Approximate the standard deviation of the MLE
sd_nonpar = sd(theta_star_nonpar)
### Parametric Bootstrap
# Initialize a vector to store results
theta_star_par <- numeric(B)
# Compute probabilities for each type based on theta_hat_observed
p1 <- (2 + theta_hat_obs) / 4
p2 <- (1 - theta_hat_obs) / 4
p3 <- (1 - theta_hat_obs) / 4
p4 <- theta_hat_obs / 4
# Run bootstap sims
for (b in 1:B) {
# Generate data from multinomial distribution
new_counts <- rmultinom(1, size = n, prob = c(p1, p2, p3, p4))
# Count number of each type
c1_boot <- new_counts[1]
c2_boot <- new_counts[2]
c3_boot <- new_counts[3]
c4_boot <- new_counts[4]
# Compute mle from simulated data
theta_star_par[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Calculate parametric standard deviation
sd_par <- sd(theta_star_par)
# Calculate bounds of confidence interval for each
lower_bound_nonpar <- theta_hat_obs - 1.96 * sd_nonpar
upper_bound_nonpar <- theta_hat_obs + 1.96 * sd_nonpar
lower_bound_par <- theta_hat_obs - 1.96 * sd_par
upper_bound_par <- theta_hat_obs + 1.96 * sd_par
# Print results
cat("Original MLE:", round(theta_hat_obs, 4), "\n\n")
cat("Nonparametric 95% CI: (",
round(lower_bound_nonpar, 4), ",",
round(upper_bound_nonpar, 4), ")\n")
cat("Parametric 95% CI:    (",
round(lower_bound_par, 4), ",",
round(upper_bound_par, 4), ")\n")
cat("True 95% CI:", "(0.2127,0.2547)", "\n")
set.seed(123)
# Define parameters
n1 <- 1195
n2 <- 750
n3 <- 729
n4 <- 326
n <- n1 + n2 + n3 + n4
# Set up functions to find MLE
score_counts <- function(theta, c1, c2, c3, c4) {
score <- c1 / (2 + theta) - (c2 + c3) / (1 - theta) + c4 / theta
return(score)
}
mle <- function(c1, c2, c3, c4) {
f <- function(t) score_counts(t, c1, c2, c3, c4)
test_lower <- score_counts(0.001, c1, c2, c3, c4)
test_upper <- score_counts(0.999, c1, c2, c3, c4)
mle <- uniroot(f, lower = 1e-3, upper = 1-1e-3)
return(mle$root)
}
# Calculate the original MLE for comparison
theta_hat_obs <- mle(n1, n2, n3, n4)
### Non-Parametric Bootstrap
# Create a vector of raw categories
cats <- c(rep("StG", n1), rep("StW", n2), rep("SuG", n3), rep("SuW", n1))
# Define number of bootstrap sims and initialize a vector to hold theta_stars
B <- 2000
theta_star_nonpar <- numeric(B)
# Loop through sims
for (b in 1:B) {
# Sample cats vector with replacement
sample <- sample(cats, size = n, replace = TRUE)
# Count the number of each type
c1_boot <- sum(sample == "StG")
c2_boot <- sum(sample == "StW")
c3_boot <- sum(sample == "SuG")
c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Approximate the standard deviation of the MLE
sd_nonpar = sd(theta_star_nonpar)
### Parametric Bootstrap
# Initialize a vector to store results
theta_star_par <- numeric(B)
# Compute probabilities for each type based on theta_hat_observed
p1 <- (2 + theta_hat_obs) / 4
p2 <- (1 - theta_hat_obs) / 4
p3 <- (1 - theta_hat_obs) / 4
p4 <- theta_hat_obs / 4
# Run bootstap sims
for (b in 1:B) {
# Generate data from multinomial distribution
new_counts <- rmultinom(1, size = n, prob = c(p1, p2, p3, p4))
# Count number of each type
c1_boot <- new_counts[1]
c2_boot <- new_counts[2]
c3_boot <- new_counts[3]
c4_boot <- new_counts[4]
# Compute mle from simulated data
theta_star_par[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Calculate parametric standard deviation
sd_par <- sd(theta_star_par)
# Calculate bounds of confidence interval for each
lower_bound_nonpar <- theta_hat_obs - 1.96 * sd_nonpar
upper_bound_nonpar <- theta_hat_obs + 1.96 * sd_nonpar
lower_bound_par <- theta_hat_obs - 1.96 * sd_par
upper_bound_par <- theta_hat_obs + 1.96 * sd_par
# Print results
cat("Original MLE:", round(theta_hat_obs, 4), "\n\n")
cat("Nonparametric 95% CI: (",
round(lower_bound_nonpar, 4), ",",
round(upper_bound_nonpar, 4), ")\n")
cat("Parametric 95% CI: (",
round(lower_bound_par, 4), ",",
round(upper_bound_par, 4), ")\n")
cat("True 95% CI:", "(0.2127,0.2547)", "\n")
set.seed(123)
# Define parameters
n1 <- 1195
n2 <- 750
n3 <- 729
n4 <- 326
n <- n1 + n2 + n3 + n4
# Set up functions to find MLE
score_counts <- function(theta, c1, c2, c3, c4) {
score <- c1 / (2 + theta) - (c2 + c3) / (1 - theta) + c4 / theta
return(score)
}
mle <- function(c1, c2, c3, c4) {
f <- function(t) score_counts(t, c1, c2, c3, c4)
test_lower <- score_counts(0.001, c1, c2, c3, c4)
test_upper <- score_counts(0.999, c1, c2, c3, c4)
mle <- uniroot(f, lower = 1e-3, upper = 1-1e-3)
return(mle$root)
}
# Calculate the original MLE for comparison
theta_hat_obs <- mle(n1, n2, n3, n4)
### Non-Parametric Bootstrap
# Create a vector of raw categories
cats <- c(rep("StG", n1), rep("StW", n2), rep("SuG", n3), rep("SuW", n1))
# Define number of bootstrap sims and initialize a vector to hold theta_stars
B <- 2000
theta_star_nonpar <- numeric(B)
# Loop through sims
for (b in 1:B) {
# Sample cats vector with replacement
sample <- sample(cats, size = n, replace = TRUE)
# Count the number of each type
c1_boot <- sum(sample == "StG")
c2_boot <- sum(sample == "StW")
c3_boot <- sum(sample == "SuG")
c4_boot <- sum(sample == "SuW")
# Find mle of bootstrap sim
theta_star_nonpar[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Approximate the standard deviation of the MLE
sd_nonpar = sd(theta_star_nonpar)
### Parametric Bootstrap
# Initialize a vector to store results
theta_star_par <- numeric(B)
# Compute probabilities for each type based on theta_hat_observed
p1 <- (2 + theta_hat_obs) / 4
p2 <- (1 - theta_hat_obs) / 4
p3 <- (1 - theta_hat_obs) / 4
p4 <- theta_hat_obs / 4
# Run bootstap sims
for (b in 1:B) {
# Generate data from multinomial distribution
new_counts <- rmultinom(1, size = n, prob = c(p1, p2, p3, p4))
# Count number of each type
c1_boot <- new_counts[1]
c2_boot <- new_counts[2]
c3_boot <- new_counts[3]
c4_boot <- new_counts[4]
# Compute mle from simulated data
theta_star_par[b] <- mle(c1_boot, c2_boot, c3_boot, c4_boot)
}
# Calculate parametric standard deviation
sd_par <- sd(theta_star_par)
# Calculate bounds of confidence interval for each
lower_bound_nonpar <- theta_hat_obs - 1.96 * sd_nonpar
upper_bound_nonpar <- theta_hat_obs + 1.96 * sd_nonpar
lower_bound_par <- theta_hat_obs - 1.96 * sd_par
upper_bound_par <- theta_hat_obs + 1.96 * sd_par
# Print results
cat("Original MLE:", round(theta_hat_obs, 4), "\n\n")
cat("Nonparametric 95% CI: (",
round(lower_bound_nonpar, 4), ",",
round(upper_bound_nonpar, 4), ")\n")
cat("Parametric 95% CI: (",
round(lower_bound_par, 4), ",",
round(upper_bound_par, 4), ")\n")
cat("True 95% CI:", "( 0.2127,0.2547 )", "\n")
R.home("bin")
R.home
# Load data from csv file
gambia <- read.csv("gambia_data.csv")
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, dependencies = TRUE)
}
}
# Load data from csv file
gambia <- read.csv("gambia_data.csv")
setwd("~/Desktop/Masters Second Semester/Statistics/Project/R2D2Project")
# Load data from csv file
gambia <- read.csv("gambia_data.csv")
# Load the package
library(r2d2glmm)
# Look at data
head(gambia)
# Load data from csv file
gambia <- read.csv("gambia_data.csv")
# Load the package
library("r2d2glmm")
# Look at data
head(gambia)
# Perform the analysis
model <- r2d2glmm(formula = cbind(positive, negative) ~ 1 + (1|village), data = gambia, family = binomial)
# Load data from csv file
gambia <- read.csv("gambia_data.csv")
# Load the package
library("r2d2glmm")
# Look at data
head(gambia)
# Perform the analysis
model <- r2d2glmm(formula = cbind(positive, negative) ~ 1 + (1|village), data = gambia, family = binomial)
# Load data from csv file
gambia <- read.csv("gambia_data.csv")
# Load the package
library("r2d2glmm")
# Look at data
head(gambia)
# Perform the analysis
summary(gambia)
